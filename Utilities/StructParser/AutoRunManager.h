#ifndef _AUTORUNMANAGER_H_
#define _AUTORUNMANAGER_H_

//this file contains a class to load in the autogenerated file which tracks all the Magic commands,
//process the data, add and remove enums, and write out that file

#include "stdio.h"
#include "tokenizer.h"
#include "windows.h"
#include "SourceParserBaseClass.h"


#define MAX_AUTORUN_COMMAND_LENGTH 128

typedef enum
{
	//NOTE NOTE NOTE if you muck with this list, change the constant value in StructInit which does
	//slow inits when the init is happening before or during INTERNAL

	//all the _ORDER_ magicwords must be in order
	AUTORUN_ORDER_FIRST,
	AUTORUN_ORDER_SECOND,
	AUTORUN_ORDER_INTERNAL,
	AUTORUN_ORDER_POSTINTERNAL,
	AUTORUN_ORDER_EARLY,
	AUTORUN_ORDER_NORMAL,
	AUTORUN_ORDER_LATE,

	AUTORUN_ORDER_FILE, //auto_runs that happen after the file system has started up, called separately from the above

	AUTORUN_ORDER_COUNT,
	AUTORUN_WILDCARD = AUTORUN_ORDER_COUNT,
	AUTORUN_ANON,


	//this thing is part of the auto-dependency startup system, and thus is not acutally autorunned,
	//but has a bunch of fixup stuff autorunned
	AUTORUN_STARTUP,
} enumAutoRunMagicWords;


typedef struct
	{
		//the name of the function in source code
		char functionName[MAX_AUTORUN_COMMAND_LENGTH];

		char sourceFileName[MAX_PATH];

		int iOrder; //0 through 3

		//some auto-runs have code and and declarations built in
		char *pDeclarations;
		char *pCode;

		//this thing is an auto_startup thing, and thus should not actually get automatically run,
		//but should 
		char *pAutoStartupName;
		char *pAutoStartupDependencyString;
		int bAutoStartupStartsOn;

		IfDefStack *pIfDefStack;
	} AUTO_RUN_STRUCT;

class AutoRunManager : public SourceParserBaseClass
{
public:
	AutoRunManager();
	~AutoRunManager();

public:
	virtual void SetProjectPathAndName(char *pProjectPath, char *pProjectName);
	virtual bool LoadStoredData(bool bForceReset);

	virtual void ResetSourceFile(char *pSourceFileName);

	virtual bool WriteOutData(void);

	virtual char *GetMagicWord(int iWhichMagicWord);

	//note that iWhichMagicWord can be MAGICWORD_BEGINING_OF_FILE or MAGICWORD_END_OF_FILE
	virtual void FoundMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, int iWhichMagicWord, char *pMagicWordString);

	//returns number of dependencies found
	virtual int ProcessDataSingleFile(char *pSourceFileName, char *pDependencies[MAX_DEPENDENCIES_SINGLE_FILE]);

	virtual bool DoesFileNeedUpdating(char *pFileName);

	virtual char *GetAutoGenCFileName1(void) { return m_AutoRunFileName; }

	void AddAutoRun(char *pFuncName, char *pSourceFileName);

	void AddAutoRunWithBody(char *pFuncName, char *pSourceFileName, char *pDeclarations, char *pCode, int iOrder, IfDefStack *pIfDefs);

	void AddAutoRunSpecial(char *pFuncName, char *pSourceFileName, bool bCheckIfAlreadyExists, int iOrder);

	void AddAutoRunWithIfDefs(char *pFuncName, char *pSourceFileName, IfDefStack *pIfDefs);
private:
	


	
	AUTO_RUN_STRUCT **m_ppAutoRuns;

	char m_AutoRunFileName[MAX_PATH];
	char m_ShortAutoRunFileName[MAX_PATH];

	char m_ProjectName[MAX_PATH];

private:
	static void DeleteAutoRun(AUTO_RUN_STRUCT *pAutoRun);
	void WriteOutAnonAutoRunIncludes(FILE *pOutFile);


};


		
#endif