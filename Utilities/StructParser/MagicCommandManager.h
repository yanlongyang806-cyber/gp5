#ifndef _DEBUGCOMMANDMANAGER_H_
#define _DEBUGCOMMANDMANAGER_H_

//this file contains a class to load in the autogenerated file which tracks all the Magic commands,
//process the data, add and remove enums, and write out that file

#include "stdio.h"
#include "tokenizer.h"
#include "windows.h"
#include "SourceParserBaseClass.h"

#define MAX_EXPRESSION_LISTS 64

//if you change this, update MAX_CATEGORY_NAME_LENGTH in cmd_http.c
#define MAX_MAGICCOMMANDNAMELENGTH 128

#define MAX_MAGICCOMMAND_ARGS 12
#define MAX_MAGICCOMMAND_ARGTYPE_NAME_LENGTH 64
#define MAX_MAGICCOMMAND_ARGNAME_LENGTH 64
#define MAX_MAGICCOMMAND_ARGDEFAULT_LENGTH 64

#define MAX_MAGICCOMMAND_DEFINES 8

#define MAX_COMMAND_ALIASES 8

#define MAX_COMMAND_SETS 8
#define MAX_COMMAND_CATEGORIES 8

#define MAX_OVERALL_SETS 128
#define MAX_OVERALL_CATEGORIES 128

#define MAX_ERROR_FUNCTIONS_PER_COMMAND 8

#define MAX_UNIQUE_DEFINES 32

#define MAX_EXPR_CODES 1024

#define MAX_GLOBALTYPES_NAME_LEN 32
#define MAX_GLOBALTYPES_PER_AUTO_SETTING 16

class MagicCommandManager : public SourceParserBaseClass
{
public:
	MagicCommandManager();
	~MagicCommandManager();

public:
	virtual void SetProjectPathAndName(char *pProjectPath, char *pProjectName);
	virtual bool LoadStoredData(bool bForceReset);

	virtual void ResetSourceFile(char *pSourceFileName);

	virtual bool WriteOutData(void);

	virtual char *GetMagicWord(int iWhichMagicWord);

	//note that iWhichMagicWord can be MAGICWORD_BEGINING_OF_FILE or MAGICWORD_END_OF_FILE
	virtual void FoundMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, int iWhichMagicWord, char *pMagicWordString);

	//returns number of dependencies found
	virtual int ProcessDataSingleFile(char *pSourceFileName, char *pDependencies[MAX_DEPENDENCIES_SINGLE_FILE]);

	virtual bool DoesFileNeedUpdating(char *pFileName);

	virtual char *GetAutoGenCFileName1(void) { return m_MagicCommandFileName; }

	//will be NULL if this is not an executable project
	virtual char *GetAutoGenCFileName2(void) { return m_MagicCommandExecutableOnlyFileName; }

private:
	


	typedef enum
	{
		ARGTYPE_NONE,
		ARGTYPE_SINT,
		ARGTYPE_UINT,
		ARGTYPE_FLOAT,
		ARGTYPE_SINT64,
		ARGTYPE_UINT64,
		ARGTYPE_FLOAT64,
		ARGTYPE_STRING,
		ARGTYPE_SENTENCE,
		ARGTYPE_ESCAPEDSTRING,
		ARGTYPE_BOOL,
		ARGTYPE_PACKET,

		//queued commands can have special ACMD_POINTER args that are treated as void*
		ARGTYPE_VOIDSTAR,

		
		ARGTYPE_VEC3_POINTER,
		ARGTYPE_VEC3_DIRECT,
		ARGTYPE_VEC4_POINTER,
		ARGTYPE_VEC4_DIRECT,
		ARGTYPE_MAT4_POINTER,
		ARGTYPE_MAT4_DIRECT,
		ARGTYPE_QUAT_POINTER,
		ARGTYPE_QUAT_DIRECT,

		//any type not recognized as something else is treated as a struct or an enum, and validated
		//during data checking time (if there's an * it's a struct)
		ARGTYPE_STRUCT,
		ARGTYPE_ENUM, 
		

		//these arg types are used only for ACMD_EXPR, which generates wrappers for expression functions
		ARGTYPE_EXPR_FIRST,
		ARGTYPE_EXPR_SUBEXPR_IN = ARGTYPE_EXPR_FIRST,
		ARGTYPE_EXPR_ENTARRAY_IN,
		ARGTYPE_EXPR_LOC_MAT4_IN,
		ARGTYPE_EXPR_EXPRCONTEXT,
		ARGTYPE_EXPR_ERRSTRING,
		ARGTYPE_EXPR_ERRSTRING_STATIC,
		ARGTYPE_EXPR_PARTITION,

		// This is used by ACMD_EXPR to generate a wrapper that passes the MultiVal directly.
		ARGTYPE_EXPR_CMULTIVAL,

		ARGTYPE_EXPR_OUT_FIRST,
		ARGTYPE_EXPR_INT_OUT = ARGTYPE_EXPR_OUT_FIRST,
		ARGTYPE_EXPR_FLOAT_OUT,
		ARGTYPE_EXPR_STRING_OUT,
		ARGTYPE_EXPR_LOC_MAT4_OUT,
		ARGTYPE_EXPR_VEC4_OUT,
		ARGTYPE_EXPR_ENTARRAY_IN_OUT,
		ARGTYPE_EXPR_ENTARRAY_OUT,
		ARGTYPE_EXPR_FUNCRETURNVAL, //only legal as return type of function, not in argument list
		
		ARGTYPE_EXPR_LAST = ARGTYPE_EXPR_FUNCRETURNVAL,
	
		//from here down, "special" argument types are not passed in with the command, but are
		//automatically passed into the command function from the auto-generated wrapper
		//
		//all must be pointers
		ARGTYPE_FIRST_SPECIAL,
		ARGTYPE_ENTITY = ARGTYPE_FIRST_SPECIAL,
		ARGTYPE_CMD,
		ARGTYPE_CMDCONTEXT,
		ARGTYPE_SLOWCOMMANDID,
		ARGTYPE_TRANSACTIONCOMMAND,
		ARGTYPE_IGNORE,
		ARGTYPE_GENERICSERVERCMDDATA,

		ARGTYPE_LAST,
	} enumMagicCommandArgType;
	
	// Must sync up with ExprStaticCheckCategory in expression.h
	typedef enum
	{
		EXPARGCAT_NONE,
		EXPARGCAT_RESOURCE,
		EXPARGCAT_REFERENCE,
		EXPARGCAT_ENUM,
		EXPARGCAT_CUSTOM,	
	} enumExprArgCategory;


#define COMMAND_FLAG_PRIVATE					(1 << 0)
#define COMMAND_FLAG_CLIENT_ONLY				(1 << 1)
#define COMMAND_FLAG_SERVER_ONLY				(1 << 2)
#define COMMAND_FLAG_REMOTE						(1 << 3)
#define COMMAND_FLAG_SLOW_REMOTE				(1 << 4)
#define COMMAND_FLAG_GLOBAL						(1 << 5)
#define COMMAND_FLAG_QUEUED						(1 << 6)
#define COMMAND_FLAG_HIDE						(1 << 7)
#define COMMAND_FLAG_TESTCLIENT					(1 << 8)
#define COMMAND_FLAG_CLIENT_WRAPPER 			(1 << 9) // should generate ClientCmd_ wrapper
#define COMMAND_FLAG_SERVER_WRAPPER 			(1 << 10) // should generate ServerCmd_ wrapper
#define COMMAND_FLAG_EXPR_WRAPPER				(1 << 11) // should generate _EXPRFUNCWRAPPER wrapper
#define COMMAND_FLAG_NOTESTCLIENT				(1 << 12)
#define COMMAND_FLAG_ADD_TO_GLOBAL_EXPR_TABLE	(1 << 13)
#define COMMAND_FLAG_EARLYCOMMANDLINE			(1 << 14)
#define COMMAND_FLAG_COMMANDLINE				(1 << 15)
#define COMMAND_FLAG_RETVAL_ALLOW_NULL			(1 << 16) //found SA_RET_OP* (expr only)
#define COMMAND_FLAG_RETVAL_DONT_ALLOW_NULL		(1 << 17) //found SA_RET_NN* (expr only)
#define COMMAND_FLAG_MULTIPLE_RECIPIENTS		(1 << 18) //make a multiplexed wrapper for this remote command (in addition to the normal one)
#define COMMAND_FLAG_NONSTATICINTERNALCMD		(1 << 19) //makes the interally generated Cmd be non-static in case someone needs to poke into it for some reason
#define COMMAND_FLAG_STATIC_RETURN_STRUCT		(1 << 20) //after getting a structptr out of the wrapper func, do NOT StructDestroy it
#define COMMAND_FLAG_COMMANDLINE_ONLY			(1 << 21)
#define COMMAND_FLAG_PASSENTITY					(1 << 22) //If the first parameter is an Entity to be passed in
#define COMMAND_FLAG_PACKETERRORCALLBACK		(1 << 23) //only valid for remote commands with no return value. The prototype will
														  //have extra arguments for a TransServerPacketFailureCB
#define COMMAND_FLAG_IGNOREPARSEERRORS			(1 << 24)
#define COMMAND_FLAG_FORCEWRITECURFILEINSTRUCTS (1 << 25)

#define COMMAND_FLAG_COMMANDVAR_STRING_IS_ESTRING (1 << 26)

#define COMMAND_FLAG_GENERICCLIENT_WRAPPER (1 << 27)
#define COMMAND_FLAG_GENERICSERVER_WRAPPER (1 << 28)

#define COMMAND_FLAG_CLIENT_WRAPPER_FAST (1 << 29)

#define COMMAND_FLAG_INTERSHARD (1 << 30)

#define COMMAND_FLAG_CACHE_AUTOCOMPLETE (1 << 31)


#define COMMAND_FLAG2_ALLOW_JSONRPC (1 << 0)

#define COMMAND_EXPR_FLAG_SA_PRE_OP				(1 << 0)
#define COMMAND_EXPR_FLAG_SA_PRE_NN				(1 << 1)
#define COMMAND_EXPR_FLAG_SELF_PTR				(1 << 2)

#define ARGFLAG_OWNABLE							(1 << 1) //only legal for structs... means that instead of passing *pStruct into the wrapper and the cleaning it up afterwards,
														 //should pass **ppStruct into the wrapper, and not clean it up if the handle now points to NULL

	typedef struct
	{
		int iNumGlobalTypes;
		char GlobalTypeNames[MAX_GLOBALTYPES_PER_AUTO_SETTING][MAX_GLOBALTYPES_NAME_LEN];
	} AUTO_SETTING_GLOBAL_TYPES;

	typedef struct MAGIC_COMMAND_ARG
	{
		enumMagicCommandArgType argType;
		char argTypeName[MAX_MAGICCOMMAND_ARGTYPE_NAME_LENGTH];
		char argName[MAX_MAGICCOMMAND_ARGNAME_LENGTH];
		U32 argFlags;

		char argNameListTypeName[MAX_MAGICCOMMANDNAMELENGTH];
		char argNameListDataPointerName[MAX_MAGICCOMMANDNAMELENGTH];
		bool argNameListDataPointerWasString;

	//static checking type for each parameter for expression functions
		char expressionStaticCheckParamType[MAX_MAGICCOMMANDNAMELENGTH];

		int iExpressionArgFlags;
		enumExprArgCategory iExpressionArgCategory;

		bool bHasDefaultInt;
		int iDefaultInt;

		bool bHasDefaultString;
		char defaultString[MAX_MAGICCOMMAND_ARGTYPE_NAME_LENGTH];
	} MAGIC_COMMAND_ARG;

	typedef struct
	{
		//COMAND_FLAG_XXX flags
		int iCommandFlags;

		//COMMAND_FLAG2_XXX
		int iCommandFlags2; 

		//the name of the function in source code
		char functionName[MAX_MAGICCOMMANDNAMELENGTH];

		//the name of the command. Defaults to the function name
		char commandName[MAX_MAGICCOMMANDNAMELENGTH];

		// Command name, converted to a safe form
		char safeCommandName[MAX_MAGICCOMMANDNAMELENGTH];

		//extra names for the command
		char commandAliases[MAX_COMMAND_ALIASES][MAX_MAGICCOMMANDNAMELENGTH];

		//what "set" of commands this is in. If this is set, then this command will end up in
		//an array of commands that is NOT automatically added to the global list
		char commandSets[MAX_COMMAND_SETS][MAX_MAGICCOMMANDNAMELENGTH];

		//the "categories" of the command. Used to generate multiple wiki pages
		char commandCategories[MAX_COMMAND_CATEGORIES][MAX_MAGICCOMMANDNAMELENGTH];

		char sourceFileName[MAX_PATH];
		int iLineNum;

		MAGIC_COMMAND_ARG **ppArgs;

		//namelist stuff relating to auto-completion for command args
	
		//will recognize return types of int, float, string, struct
		enumMagicCommandArgType eReturnType;
		char returnTypeName[MAX_MAGICCOMMAND_ARGTYPE_NAME_LENGTH];
		char returnStaticCheckParamType[MAX_MAGICCOMMANDNAMELENGTH];
		enumExprArgCategory iReturnStaticCheckCategory;

		int iAccessLevel; //defaults to 9

		char serverSpecificAccessLevel_ServerName[64]; //if this string is nonempty, then we change the access level of the command at startup time on a particular server type
		int iServerSpecificAccessLevel;

		char comment[TOKENIZER_MAX_STRING_LENGTH];

		//used during WIKI export
		bool bAlreadyWroteOutComment;

		//used while writing out command sets
		bool bWritten;

		//command names of the commands for which this is the error function
		char commandsWhichThisIsTheErrorFunctionFor[MAX_ERROR_FUNCTIONS_PER_COMMAND][MAX_MAGICCOMMANDNAMELENGTH];

		//what command queue this command belongs to
		char queueName[MAX_MAGICCOMMANDNAMELENGTH];

		//"defines" in this context apply only to remote commands, and are macros that will (with #ifdefs) surround
		//the remote function prototypes and bodies
		int iNumDefines;
		char defines[MAX_MAGICCOMMAND_DEFINES][MAX_MAGICCOMMANDNAMELENGTH];

		//list of tags for this expression
		int iNumExpressionTags;
		char expressionTag[MAX_COMMAND_SETS][MAX_MAGICCOMMANDNAMELENGTH];

	

		//name of the static checking function to use for this function during expression generation
		char expressionStaticCheckFunc[MAX_MAGICCOMMANDNAMELENGTH];

		//cost for this expression function for design budgets
		//this is an int because the tokenizer apparently doesn't do floats?
		int iExpressionCost;

		IfDefStack *pIfDefStack;

		bool bIsExprCodeExample; //this was the first command in order encountered with its expr code, so use it
			//as the example version for that code

		char *pExprCode;

		char **ppProducts; //products read from ACMD_PRODUCTS

	} MAGIC_COMMAND_STRUCT;

	typedef struct
	{
		//COMAND_FLAG_XXX flags
		int iCommandFlags;

		//COMMAND_FLAG2_XXX
		int iCommandFlags2;

		char varCommandName[MAX_MAGICCOMMANDNAMELENGTH];

		char sourceFileName[MAX_PATH];
		int iLineNum;

		enumMagicCommandArgType eVarType;

		//what "set" of commands this is in. If this is set, then this command will end up in
		//an array of commands that is NOT automatically added to the global list
		char commandSets[MAX_COMMAND_SETS][MAX_MAGICCOMMANDNAMELENGTH];

		//the "categories" of the command. Used to generate multiple wiki pages
		char commandCategories[MAX_COMMAND_CATEGORIES][MAX_MAGICCOMMANDNAMELENGTH];


		//used while writing out command sets
		bool bWritten;

		char comment[TOKENIZER_MAX_STRING_LENGTH];
		//used during WIKI export
		bool bAlreadyWroteOutComment;


		int iAccessLevel;
		char serverSpecificAccessLevel_ServerName[64]; //if this string is nonempty, then we change the access level of the command at startup time on a particular server type
		int iServerSpecificAccessLevel;


		int iMaxValue;
		
		char callbackFunc[MAX_MAGICCOMMANDNAMELENGTH];

		IfDefStack *pIfDefStack;

		char **ppProducts; //products read from ACMD_PRODUCTS

		AUTO_SETTING_GLOBAL_TYPES autoSettingGlobalTypes;
	} MAGIC_COMMANDVAR_STRUCT;



	MAGIC_COMMAND_STRUCT **m_ppMagicCommands;
	MAGIC_COMMANDVAR_STRUCT **m_ppMagicCommandVars;

	char m_MagicCommandFileName[MAX_PATH];
	char m_ShortMagicCommandFileName[MAX_PATH];
	char m_MagicCommandExprCodeHeaderFileName[MAX_PATH];
	char m_MagicCommandExecutableOnlyFileName[MAX_PATH];

	char m_ProjectName[MAX_PATH];

	char m_TestClientFunctionsFileName[MAX_PATH];
	char m_TestClientFunctionsHeaderName[MAX_PATH];

	char m_RemoteFunctionsFileName[MAX_PATH];
	char m_RemoteFunctionsHeaderName[MAX_PATH];

	char m_SlowFunctionsFileName[MAX_PATH];
	char m_SlowFunctionsHeaderName[MAX_PATH];
	
	char m_QueuedFunctionsFileName[MAX_PATH];
	char m_QueuedFunctionsHeaderName[MAX_PATH];

	char m_ServerWrappersFileName[MAX_PATH];
	char m_ServerWrappersHeaderFileName[MAX_PATH];

	char m_ClientWrappersFileName[MAX_PATH];
	char m_ClientWrappersHeaderFileName[MAX_PATH];

	char m_GServerWrappersFileName[MAX_PATH];
	char m_GServerWrappersHeaderFileName[MAX_PATH];

	char m_GClientWrappersFileName[MAX_PATH];
	char m_GClientWrappersHeaderFileName[MAX_PATH];


	char m_ClientToTestClientWrappersFileName[MAX_PATH]; //wrappers for commands defined on the testclient called by the client
	char m_ClientToTestClientWrappersHeaderFileName[MAX_PATH];

	int m_iNumCategoriesWritten;
	char m_CategoriesWritten[MAX_OVERALL_CATEGORIES][MAX_MAGICCOMMANDNAMELENGTH];

	char m_AllDefines[MAX_UNIQUE_DEFINES][MAX_MAGICCOMMANDNAMELENGTH];

private:
	char *GetArgDescriptionBlock(enumMagicCommandArgType eArgType, char *pArgName, char *pTypeName,
		char *pNameListDataPointer, char *pNameListType, bool bDataPointerWasString,
		bool bHasDefaultInt, int iDefaultInt, char *pDefaultString);
	enumMagicCommandArgType GetArgTypeFromArgTypeName(char *pArgTypeName);

	bool IsPointerType(enumMagicCommandArgType eType) { return eType == ARGTYPE_VEC3_POINTER || eType == ARGTYPE_VEC4_POINTER || eType == ARGTYPE_MAT4_POINTER || eType == ARGTYPE_QUAT_POINTER; }
	bool IsDirectVersionOfPointerType(enumMagicCommandArgType eType) { return eType == ARGTYPE_VEC3_DIRECT || eType == ARGTYPE_VEC4_DIRECT || eType == ARGTYPE_MAT4_DIRECT || eType == ARGTYPE_QUAT_DIRECT; }

	void WriteOutWikiFileForCategory(char *pCategoryName, bool bExpressionCommands);
	bool CommandHasCorrectExpressionNessForWiki(MAGIC_COMMAND_STRUCT *pCommand,
		bool bWantExpressionCommands);

	char *GetWikiNameForArgType(enumMagicCommandArgType eArgType, char *pArgTypeName);
	char *GetWikiNameForReturnType(enumMagicCommandArgType eArgType, char *pArgTypeName);
	char *GetReturnTypeName(MAGIC_COMMAND_STRUCT *pCommand);
	char *GetReturnValueMultiValTypeName(enumMagicCommandArgType eArgType);

	void WriteCommandVarSetData(FILE *pOutFile, MAGIC_COMMANDVAR_STRUCT *pCommandVar);
	void WriteCommandSetData(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);

	void FoundCommandMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, bool bIsRemoteCommand, bool bIsSlowCommand, bool bIsQueuedCommand, bool bIsExprFunc, bool bIsExprFuncStaticCheck);
	void FoundCommandVarMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, enumMagicCommandArgType eType);

	bool CommandHasArgOfType(MAGIC_COMMAND_STRUCT *pCommand, enumMagicCommandArgType eType);
	int CountArgsOfType(MAGIC_COMMAND_STRUCT *pCommand, enumMagicCommandArgType eType);
	int GetNumNormalArgs(MAGIC_COMMAND_STRUCT *pCommand);
	bool CommandCanHaveErrorFunction(MAGIC_COMMAND_STRUCT *pCommand);
	char *GetErrorFunctionName(char *pCommandName);
	void VerifyCommandValidity(Tokenizer *pTokenizer, MAGIC_COMMAND_STRUCT *pCommand);
	void VerifyCommandValidityPreWriteOut(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutFilesForTestClient(void);

	char *GetTestClientPrototypeArgName(enumMagicCommandArgType eType);

	void WriteOutPrototypesForTestClient(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, int iPrefixLen);
	void WriteOutFunctionBodiesForTestClient(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, int iPrefixLen);

	void WriteCompleteTestClientPrototype(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
//	DEPRECATED - VAS 02/17/10
// 	void WriteCompleteTestClientPrototype_Blocking(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
// 	void WriteCompleteTestClientPrototype_Struct(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
// 	void WriteCompleteTestClientPrototype_Callback(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
// 	void WriteCompleteTestClientPrototype_UserBuff(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
// 	void WriteCompleteTestClientPrototype_IntReturn(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
// 	void WriteCompleteTestClientPrototype_Vec3Return(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
// 	void WriteCompleteTestClientPrototype_Vec4Return(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
// 	void WriteCompleteTestClientPrototype_FloatReturn(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
// 	void WriteCompleteTestClientPrototype_StructReturn(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
// 	void WriteCompleteTestClientPrototype_StringReturn(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);

	void WriteOutSharedFunctionBody(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, int iPrefixLen);

	//returns the length of the prefix string prepended to the command name
	int CopyCommandVarIntoCommandForSetting(MAGIC_COMMAND_STRUCT *pCommand, MAGIC_COMMANDVAR_STRUCT *pCommandVar);

	//returns the length of the prefix string prepended to the command name
	int CopyCommandVarIntoCommandForGetting(MAGIC_COMMAND_STRUCT *pCommand, MAGIC_COMMANDVAR_STRUCT *pCommandVar);

	char *GetFixedUpArgTypeNameForFuncPrototype(MAGIC_COMMAND_STRUCT *pCommand, int iArgNum);
	char *GetFixedUpArgTypeNameForReadArgs(MAGIC_COMMAND_STRUCT *pCommand, int iArgNum);

	void CommandAssert(MAGIC_COMMAND_STRUCT *pField, bool bCondition, char *pErrorMessage);
	void CommandAssertf(MAGIC_COMMAND_STRUCT *pField, bool bCondition, char *pErrorMessage, ...);

	void WriteOutMainPrototypeForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutQueuedPrototypeForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutPrototypesForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutFunctionBodiesForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutReturnPrototypeForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutRemoteCommands(void);

	void WriteOutInterShardPrototypeForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);

	void WriteOutFunctionPrototypeForSlowCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutFunctionBodyForSlowCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);

	bool CommandGetsWrittenOutInCommandSets(MAGIC_COMMAND_STRUCT *pCommand);
	bool CommandGetsWrittenOutForTestClients(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutMainQueuedCommandPrototype(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutWrapperQueuedCommandPrototype(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutPrototypesForQueuedCommand(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutBodiesForQueuedCommand(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutQueuedCommands(void);

	void WriteOutGenericArgListForCommand(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, 
	  bool bIncludeSpecialArgs, bool bOtherArgsAlreadyWritten, bool bDoubleStarForOwnable);
	void WriteOutGenericExternsAndPrototypesForCommand(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, bool bWriteNameListStuff);
	void WriteOutGenericCodeToPutArgumentsIntoEString(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, 
	   char *pEStringName, bool bEscapeAllStrings, bool bPutStructsIntoCmdParseStructList);
	void WriteOutGenericCodeToPutSingleArgumentIntoEString(FILE *pOutFile, enumMagicCommandArgType eArgType,
		char *pArgName, char *pArgTypeName, char *pEStringName, bool bEscapeAllStrings, 
		bool bPutStructsIntoCmdParseStructList, MAGIC_COMMAND_STRUCT *pCommand);

	char *GetGenericTypeNameFromType(enumMagicCommandArgType eType);

	bool CommandGetsWrittenOutForClientOrServerWrapper(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutPrototypeForServerWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutBodyForServerWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutServerWrappers(void);
	void WriteOutPrototypeForClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, bool bFast);
	void WriteOutBodyForClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, bool bFast);
	void WriteOutClientWrappers(void);

	bool CommandGetsWrittenOutForGenericServerWrapper(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutPrototypeForGenericServerWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutBodyForGenericServerWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutGenericServerWrappers(void);
	void WriteOutPrototypeForGenericClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutBodyForGenericClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutGenericClientWrappers(void);

	void WriteOutPrototypeForClientToTestClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutBodyForClientToTestClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutClientToTestClientWrappers(void);


	void WriteOutFakeIncludesForTestClient(FILE *pOutFile);
	void WriteOutFakeIncludesForRemoteCommands(FILE *pOutFile);
	void WriteOutFakeIncludesForSlowCommands(FILE *pOutFile);
	void WriteOutFakeIncludesForQueuedCommands(FILE *pOutFile);
	void WriteOutFakeIncludes(FILE *pOutFile, int iFlagToMatch);



	void FixupCommandTypes(Tokenizer *pTokenizer, MAGIC_COMMAND_STRUCT *pCommand);

	//returns true if the given command is in the given category. If the category is "", then
	//returns true if the command is in no categories
	bool CommandIsInCategory(MAGIC_COMMAND_STRUCT *pCommand, char *pCategoryName);
	bool CommandVarIsInCategory(MAGIC_COMMANDVAR_STRUCT *pCommand, char *pCategoryName);

	//returns true if the command category was already written out
	bool CommandCategoryWritten(char *pCategoryName);

	void AddCommandToSet(MAGIC_COMMAND_STRUCT *pCommand, char *pSetName, Tokenizer *pTokenizer);
	void AddCommandToCategory(MAGIC_COMMAND_STRUCT *pCommand, char *pCategoryName, Tokenizer *pTokenizer);
	void AddCommandVarToSet(MAGIC_COMMANDVAR_STRUCT *pCommandVar, char *pSetName, Tokenizer *pTokenizer);
	void AddCommandVarToCategory(MAGIC_COMMANDVAR_STRUCT *pCommandVar, char *pCategoryName, Tokenizer *pTokenizer);
	void AddCommandVarToCategory_ControllerAutoSetting(MAGIC_COMMANDVAR_STRUCT *pCommandVar, char *pCategoryName, Tokenizer *pTokenizer);

	bool ArgTypeIsExpressionOnly(enumMagicCommandArgType eArgType);
	bool CommandHasExpressionOnlyArgumentsOrReturnVals(MAGIC_COMMAND_STRUCT *pCommand);
	bool CommandNeedsNormalWrapper(MAGIC_COMMAND_STRUCT *pCommand);
	bool CommandShouldBeWrittenToWiki(MAGIC_COMMAND_STRUCT *pCommand);

	void WriteOutExpressionListStuff(FILE *pOutFile, FILE *pExprCodeHeader, FILE *pExecutableOnlyFile);

	bool DoesArgTypeNeedConstInWrapperPrototype(enumMagicCommandArgType eType, char *pTypeName);

	bool AtLeastOneCommandHasFlag(int iFlag);

	bool CurrentProjectIsTestClient(void);
	void AssertCommandIsOKForClientToTestClient(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutIfDefForIgnoringClientToTestClientWrapper(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);

	static int MagicCommandComparator(const void *p1, const void *p2);
	static int MagicCommandVarComparator(const void *p1, const void *p2);

	bool QueuedCommandTypeMightBeNull(enumMagicCommandArgType eType);

	void WriteOutIfdefsForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutEndifsForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	bool CommandHasDefine(MAGIC_COMMAND_STRUCT *pCommand, char *pDefine);
	void FindAllDefines(void);

	bool CommandShouldGetRemotePacketWrapper(MAGIC_COMMAND_STRUCT *pCommand);

	void WriteOutGenericCodeToPutArgumentsIntoPacket(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand, 
		char *pPacketName);
	void WriteOutGenericCodeToPutSingleArgumentIntoPacket(FILE *pOutFile, enumMagicCommandArgType eArgType,
		char *pArgName, char *pArgTypeName, char *pPacketName, MAGIC_COMMAND_STRUCT *pCommand);
	void WriteOutGenericPrototypeToCallFunctionFromPacket(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand, char *pPacketName);
	void WriteOutMultiRecipientPrototypeForRemoteCommand(FILE *pFile, MAGIC_COMMAND_STRUCT *pCommand);
	static void DestroyCommand(MAGIC_COMMAND_STRUCT *pCommand);
	static void DestroyCommandVar(MAGIC_COMMANDVAR_STRUCT *pCommandVar);

	char *GetShortCodeForExprArgType(MAGIC_COMMAND_STRUCT *pCommand, enumMagicCommandArgType eType, int iExprFlags);
	char *GetFullExprCode(MAGIC_COMMAND_STRUCT *pCommand);
	void WriteExprCodeIncludesForLibraries(FILE *pOutFile, char *pPrefix);

	void WriteOutExprCodeCase(FILE *pOutFile, MAGIC_COMMAND_STRUCT *pCommand);
	
	MAGIC_COMMAND_STRUCT *FindCommandByFuncName(char *pFuncName);

	void ReadGlobalTypes(Tokenizer *pTokenizer, AUTO_SETTING_GLOBAL_TYPES *pGlobalTypes);
	void ReadGlobalTypes_Parsable(Tokenizer *pTokenizer, AUTO_SETTING_GLOBAL_TYPES *pGlobalTypes);
	void WriteGlobalTypes_Parsable(FILE *pFile, AUTO_SETTING_GLOBAL_TYPES *pGlobalTypes);

	char *GetProductString(char ***pppProductEarray);

};


		
#endif
