#include "sourceparser.h"
#include "stdio.h"
#include "strutils.h"
#include "windows.h"

// X c:\src\libs\StructParserStub\ X StructParserStub.vcproj X Win32 X Debug X C:\Program Files\Microsoft Visual Studio 8\VC\ X c:\src\mastersolution\AllProjectsMasterSolution.sln

int gVerbose = 0;
int gDoMasterWikiCreation = 0;
int gSlowSafeDependencyMode = 0;

//if false, do another pass over each code file checking for if(      );
int gDontCheckForBadIfsInCode = 0;

int gDontQuerySVN = 0;


bool SlowSafeDependencyMode(void)
{
	return false; //hurray, we don't need this with IB 2010!
	/*
	static int CBRunning = -1;

	if (CBRunning == -1)
	{
		CBRunning = ProcessCount("continuousbuilder.exe");
	}

	return CBRunning || gSlowSafeDependencyMode;*/
}

typedef struct
{
	char optionName[128];
	int *pOption;
} OPTION_STRUCT;

OPTION_STRUCT gOptions[] = 
{
	{
		"Verbose",
		&gVerbose
	},
	{
		"DoMasterWikiCreation",
		&gDoMasterWikiCreation
	},
	{
		"SlowSafeDependencyMode",
		&gSlowSafeDependencyMode
	},
	{
		"DontCheckForBadIfsInCode",
		&gDontCheckForBadIfsInCode
	},
	{
		"DontQuerySVN",
		&gDontQuerySVN
	}
};

#define NUM_OPTIONS (sizeof(gOptions) / sizeof(gOptions[0]))

int ReadOptionsFromFile(Tokenizer *pTokenizer)
{
	Token token;
	enumTokenType eType;

	int iNumFound = 0;

	while ((eType = pTokenizer->GetNextToken(&token)) != TOKEN_NONE)
	{
		if (eType == TOKEN_IDENTIFIER)
		{
			int i;

			for (i=0; i < NUM_OPTIONS; i++)
			{
				if (strcmp(gOptions[i].optionName, token.sVal) == 0)
				{
					pTokenizer->AssertNextTokenTypeAndGet(&token, TOKEN_RESERVEDWORD, RW_EQUALS, "Expected = after option name");
					pTokenizer->AssertNextTokenTypeAndGet(&token, TOKEN_INT, 0, "Expected int after =");
					*(gOptions[i].pOption) = token.iVal;

					iNumFound++;
				}
			}
		}
	}

	return iNumFound;
}

void WriteOptionsFile(char *pFileName)
{
	int i;

	FILE *pOutFile = fopen_nofail(pFileName, "wt");

	fprintf(pOutFile, "//This file contains options for StructParser. It is autogenerated as new options occur.\n//The syntax is pretty self-explanatory\n//autogenerated" "nocheckin\n");

	for (i = 0; i < NUM_OPTIONS; i++)
	{
		fprintf(pOutFile, "%s = %d\n", gOptions[i].optionName, *(gOptions[i].pOption));
	}

	fclose(pOutFile);
}




void ProcessOptionFile(void)
{
	char exeName[MAX_PATH];
	char optionFileName[MAX_PATH];
	int iNumOptionsFound = 0;

	Tokenizer tokenizer;
	
	GetModuleFileName(NULL, exeName, MAX_PATH);

	TruncateStringAtLastOccurrence(exeName, '\\');

	sprintf(optionFileName, "%s\\%s", exeName, "structparser_settings.txt");

	if (tokenizer.LoadFromFile(optionFileName))
	{
		iNumOptionsFound = ReadOptionsFromFile(&tokenizer);
	}

	if (iNumOptionsFound != NUM_OPTIONS)
	{
		WriteOptionsFile(optionFileName);
	}
}


// Return true if the user has recently created a file that indicates StructParser should not be run.
bool StructParserSuppressed()
{
	// Check if the file exists.
	HANDLE file = CreateFile("c:\\temp\\StructParserSuppress.txt", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (file == INVALID_HANDLE_VALUE)
		return false;
	
	// Get the file's last modification time.
	FILETIME filetime;
	BOOL success = GetFileTime(file, NULL, NULL, &filetime);
	assert(success);
	success = CloseHandle(file);
	assert(success);
	unsigned __int64 modified = (unsigned __int64)filetime.dwHighDateTime << 32 | filetime.dwLowDateTime;

	// Get the time right now.
	GetSystemTimeAsFileTime(&filetime);
	unsigned __int64 now = (unsigned __int64)filetime.dwHighDateTime << 32 | filetime.dwLowDateTime;

	// Calculate age in tenths of microseconds.
	if (modified > now)
		return false;
	unsigned __int64 age = now - modified;

	// Check if the file is too old.
	if (age > (unsigned __int64)60*60*1000*1000*10)  // One hour
		return false;

	return true;
}

#pragma comment(lib, "Version.lib")
void CheckBuilderConfiguration()
{
	char *pairs[2][2] = {
		{"C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\cl.exe",
		"C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\bin\\mspft80.dll"},
		{"C:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\bin\\cl.exe",
		"C:\\Program Files\\Microsoft Visual Studio 10.0\\VC\\bin\\mspft80.dll"},
	};
	int i;
	for (i=0; i<ARRAYSIZE(pairs); i++)
	{
		if (FileExists(pairs[i][0]))
		{
			if (!FileExists(pairs[i][1]))
			{
				printf("structparser(1) : error S0000 : (StructParser) VS2010 configured incorrectly: %s not found.  Install the Windows SDK.\n", pairs[i][1]);
			}

			// read file version info
			DWORD dwDummyHandle; // will always be set to zero
			DWORD len = GetFileVersionInfoSize( pairs[i][0], &dwDummyHandle );
			if (len > 0)
			{
				char *m_pVersionInfo = (char*)calloc( 1, len ); // allocate version info
				if (GetFileVersionInfo( pairs[i][0], 0, len, m_pVersionInfo))
				{
					LPVOID lpvi;
					UINT iLen;
					if (VerQueryValue(m_pVersionInfo, "\\", &lpvi, &iLen))
					{
						VS_FIXEDFILEINFO fileInfo;
						memset(&fileInfo, 0, sizeof(VS_FIXEDFILEINFO));
						// copy fixed info to myself, which am derived from VS_FIXEDFILEINFO
						fileInfo = *(VS_FIXEDFILEINFO*)lpvi;

						DWORD a = ((fileInfo.dwProductVersionMS >> 16) & 0xFFFF),
							b = (fileInfo.dwProductVersionMS & 0xFFFF),
							c = ((fileInfo.dwProductVersionLS >> 16) & 0xFFFF),
							d = (fileInfo.dwProductVersionLS & 0xFFFF);
						// VS2010 vanilla: 10.0.30319.1
						// VS2010 SP1: 16.0.31118.1
						//printf("%d %d %d %d", a, b, c, d);
						if (c < 31118)
						{
							printf("structparser(1) : error S0000 : (StructParser) VS2010 configured incorrectly: VS2010 SP1 not installed (cl.exe version too old: %d.%d.%d.%d).\n", a, b, c, d);
						}
					}
				}
				free(m_pVersionInfo);
			}
		}



	}



}

int main(int argc, char* argv[])
{		

	int i;


	/*char *pStartTest = "This \"string\" has \\ slashes % ___ and _stuff_ \"";
	char *pEscaped = strdup(EscapeString_Underscore(pStartTest));
	UnEscapeString_Underscore(pEscaped);
	int iCmp = strcmp(pStartTest, pEscaped);*/


/*
	{
		Tokenizer tokenizer;
		
		enumTokenType eType;
		Token token;
		
		tokenizer.LoadFromFile("c:\\alextest.txt");
		
		tokenizer.SetCSourceStyleStrings(true);
		tokenizer.SetNoNewlinesInStrings(true);

		do
		{
			eType = tokenizer.GetNextToken(&token);
		} while (eType != TOKEN_NONE);
	}
*/

	// If a file is present that would suppress StructParser, return successfully without doing anything.
	if (StructParserSuppressed())
	{
		puts("Warning: StructParser suppressed.");
		return 0;
	}

	CheckBuilderConfiguration();

	ProcessOptionFile();

	SetPriorityClass(GetCurrentProcess(), BELOW_NORMAL_PRIORITY_CLASS);

	char commandLine[2000] = {0};

	commandLine[0] = 0;


	if (argc > 2)
	{

		for (i=0; i < argc; i++)
		{
			sprintf(commandLine + strlen(commandLine), " %s", argv[i]);
		}

		if (strstri(commandLine, "structParserStub"))
		{

			FILE *pLastCommandLineFile = fopen("c:\\temp\\StructParserLastCommandLine.txt", "wt");
			if (pLastCommandLineFile)
			{
				fprintf(pLastCommandLineFile, "%s", commandLine);
			}
			fclose(pLastCommandLineFile);
		}
	}
	else
	{
		printf("No command line... presumably running in debugger. Loading from c:\\temp to get last command line\n");
		FILE *pLastCommandLineFile = fopen("c:\\temp\\StructParserLastCommandLine.txt", "rt");
		if (pLastCommandLineFile)
		{
			fread(commandLine, sizeof(commandLine) - 1, 1, pLastCommandLineFile);
			fclose(pLastCommandLineFile);
		}
	}

	char *pSubStrings[20];
	


	int iStringsFound = SubDivideStringAndRemoveWhiteSpace(pSubStrings, commandLine, 'X', 20);

	if (iStringsFound != 7)
	{
		printf("ERROR: Couldn't find required arguments for StructParser. Should be structparser X projectpath X projectfilename X pcurtarget X pcurconfiguration X pcurVCDirectory X SolutionPath");
	


		for (i=0; i < iStringsFound; i++)
		{
			printf("%d: %s\n", i, pSubStrings[i]);
		}
	
		fflush(stdout);
		BreakIfInDebugger();

		Sleep(100);

		exit(1);

	}

	for (i=0; i < iStringsFound; i++)
	{
        printf(i < iStringsFound-1? "%s X ":"%s", pSubStrings[i]);
	}
	printf("\n");
    fflush(stdout);

// 	if (strstr(pSubStrings[5], "Studio 10.0"))
// 	{
// 		printf("Skipping StructParser on VS2010\n");
// 		return 0;
// 	}

	SourceParser sourceParser;

	sourceParser.ParseSource(pSubStrings[1], pSubStrings[2], pSubStrings[3], pSubStrings[4], pSubStrings[5], pSubStrings[6], argv[0], NULL);

	DeleteMaybeDeleteFilesNow();

	return 0;
}