#ifndef _AUTOTRANSACTIONMANAGER_H_
#define _AUTOTRANSACTIONMANAGER_H_

//this file contains a class to load in the autogenerated file which tracks all the Magic commands,
//process the data, add and remove enums, and write out that file

#include "stdio.h"
#include "tokenizer.h"
#include "windows.h"
#include "SourceParserBaseClass.h"

#define MAX_ARGS_PER_AUTO_TRANSACTION_FUNC 16


#define MAX_EXPECTED_LOCKS_STR 2048
#define MAX_EXPECTED_LOCKS MAX_CONTAINER_ARGS_PER_FUNC


typedef enum AutoTransMagicWord
{
	MAGICWORD_AUTOTRANSACTION,
	MAGICWORD_AUTOTRANSHELPER,
	MAGICWORD_AUTOTRANSHELPERSIMPLE,
} AutoTransMagicWord;


class AutoTransactionManager : public SourceParserBaseClass
{


public:
	AutoTransactionManager();
	~AutoTransactionManager();

public:
	virtual void SetProjectPathAndName(char *pProjectPath, char *pProjectName);
	virtual bool LoadStoredData(bool bForceReset);

	virtual void ResetSourceFile(char *pSourceFileName);

	virtual bool WriteOutData(void);

	virtual char *GetMagicWord(int iWhichMagicWord);

	//note that iWhichMagicWord can be MAGICWORD_BEGINING_OF_FILE or MAGICWORD_END_OF_FILE
	virtual void FoundMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, int iWhichMagicWord, char *pMagicWordString);

	void FoundAutoTransMagicWord(char *pSourceFileName, Tokenizer *pTokenizer, AutoTransMagicWord eWhich);

	//returns number of dependencies found
	virtual int ProcessDataSingleFile(char *pSourceFileName, char *pDependencies[MAX_DEPENDENCIES_SINGLE_FILE]);

	virtual bool DoesFileNeedUpdating(char *pFileName);

	virtual char *GetAutoGenCFileName1(void) { return m_AutoTransactionFileName; }

private:


	typedef enum
	{
		ATR_ARGTYPE_INT,
		ATR_ARGTYPE_INT64,
		ATR_ARGTYPE_FLOAT,
		ATR_ARGTYPE_STRING,
		ATR_ARGTYPE_CONTAINER,
		ATR_ARGTYPE_STRUCT,
	} enumAutoTransArgType;

	typedef enum
	{
		ATR_LOCK_NORMAL, //a non-indexed-lock
		ATR_LOCK_ARRAY_OPS,
		ATR_LOCK_INDEXED_NULLISOK,
		ATR_LOCK_INDEXED_FAILONNULL,
	} enumAutoTransLockType;

	typedef enum enumArgFlags
	{
		ARGFLAG_ISPOINTER = 1,
		ARGFLAG_ISEARRAY = 1 << 1,
		ARGFLAG_FOUNDNONCONTAINER = 1 << 2,
		ARGFLAG_ALLOWFULLLOCK = 1 << 3,
		ARGFLAG_FOUNDCONST = 1 << 4,
	} enumArgFlags;

	typedef struct
	{
		int eArgFlags;
		enumAutoTransArgType eArgType;
		char argTypeName[MAX_NAME_LENGTH];
		char argName[MAX_NAME_LENGTH];

	} ArgStruct;

	//a simple arg to an ATR or ATR_HELPER func is an argument passed in which is NOT
	//a magical container or anything of that sort, just {const} type {*}name
	//
	//We don't care about the arg type, trusting the C compiler to catch any errors of that
	//sort
	typedef struct SimpleArg
	{
		char argName[MAX_NAME_LENGTH];
		int iArgIndex;
	} SimpleArg;

	typedef struct SimpleArgList
	{
		SimpleArg **ppSimpleArgs;
	} SimpleArgList;


	typedef enum
	{
		DEREFTYPE_NORMAL,
		DEREFTYPE_ARRAYOPS,
		DEREFTYPE_ARRAYOPS_SPECIAL,
	} enumDerefType;

	typedef struct Dereference
	{
		int iLineNum;
		char derefString[MAX_NAME_LENGTH];
		enumDerefType eType;

	} Dereference;


	typedef struct DereferenceList
	{
		Dereference **ppDereferences;
	} DereferenceList;

	//a ATR or ATR_HELPER also has a list of Container args, which we set up a simple list struct for
	typedef struct ContainerArg
	{
		char argName[MAX_NAME_LENGTH];
		char argTypeName[MAX_NAME_LENGTH];

		int iArgIndex;
		int eArgFlags;
		DereferenceList dereferenceList;
		char expectedLocks[MAX_EXPECTED_LOCKS_STR];
	} ContainerArg;
	
	typedef struct ContainerArgList
	{
		ContainerArg **ppContainerArgs;
	} ContainerArgList;




	//if we have a function with a simple arg list, we can look at a function call inside
	//that function and figure out which of the arguments being passed in are either literal
	//strings/ints or simple args
	typedef enum
	{
		RECURSEARGTYPE_BAD = -1,
		RECURSEARGTYPE_LITERAL_INT,
		RECURSEARGTYPE_LITERAL_STRING,
		RECURSEARGTYPE_PARENT_SIMPLE_ARG,
		RECURSEARGTYPE_IDENTIFIER_INT,
		RECURSEARGTYPE_IDENTIFIER_STRING,
	} enumRecurseArgType;

	typedef struct RecursingFunctionCallSimpleArg
	{
		enumRecurseArgType eType;
		int iVal; //index of parent simple arg, or literal int value
		char sVal[MAX_NAME_LENGTH * 2];
	
		int iArgIndex;
	} RecursingFunctionCallSimpleArg;

	typedef struct RecursingFunctionCallSimpleArgList
	{
		RecursingFunctionCallSimpleArg **ppRecursingArgs;
	} RecursingFunctionCallSimpleArgList;

	typedef struct RecursingFunctionCallSimpleIdentifierArg
	{
		int iArgIndex;
		char sVal[MAX_NAME_LENGTH];
	} RecursingFunctionCallSimpleIdentifierArg;

	typedef struct  RecursingFunctionCallSimpleIdentifierArgList
	{
		RecursingFunctionCallSimpleIdentifierArg **ppIdentifierArgs;
	} RecursingFunctionCallSimpleIdentifierArgList;



	typedef struct RecursingFunctionCallContainerArg
	{
		int iParentArgIndex;
		int iRecursingArgIndex;
		char derefString[MAX_NAME_LENGTH];
	} RecursingFunctionCallContainerArg;
	
	typedef struct RecursingFunctionCallContainerArgList
	{
		RecursingFunctionCallContainerArg **ppRecursingArgs;
	} RecursingFunctionCallContainerArgList;


	typedef struct RecursingFunctionCall
	{
		int UID;
		int iLineNum;
		char funcName[MAX_NAME_LENGTH];
		RecursingFunctionCallSimpleArgList recursingSimpleArgList;
		RecursingFunctionCallContainerArgList recursingContainerArgList;
		RecursingFunctionCallSimpleIdentifierArgList simpleIdentifierArgList;
	} RecursingFunctionCall;

	typedef struct RecursingFunctionCallList
	{
		RecursingFunctionCall **ppFunctionCalls;
	} RecursingFunctionCallList;
		


	typedef struct EarrayUse
	{
		int iContainerArgIndex;
		char containerArgDerefString[MAX_NAME_LENGTH];
		enumRecurseArgType eIndexType;
		int iVal;
		char sVal[MAX_NAME_LENGTH];
		enumAutoTransLockType eLockType;

		char sourceFileName[MAX_PATH];
		int iLineNum;
		char globalIncludeFile[MAX_PATH];
	} EarrayUse;

	typedef struct EarrayUseList
	{
		EarrayUse **ppEarrayUses;
	} EarrayUseList;

	typedef enum enumAutoTransFlags
	{
	ATRFLAG_IS_HELPER = 1 << 0,
	ATRFLAG_MAKE_APPEND_VERSION = 1 << 1,
	ATRFLAG_MAKE_DEFERRED_VERSION = 1 << 2,
	ATRFLAG_IS_HELPER_SIMPLE = 1 << 3,
	ATRFLAG_DOES_RETURN_LOGGING = 1 << 4,
	} enumAutoTransFlags;

	typedef struct ExpectedLock
	{
		char containerArgName[MAX_NAME_LENGTH];
		char expectedLocks[MAX_EXPECTED_LOCKS_STR];
	} ExpectedLock;

	typedef struct ExpectedLockList
	{
		ExpectedLock **ppExpectedLocks;
	} ExpectedLockList;

	typedef struct
	{
		char functionName[MAX_NAME_LENGTH];

		char sourceFileName[MAX_PATH];
		int iSourceFileLineNum;
		int iStartingTokenizerOffset;
		bool bRecursingAlreadyDone;
		U32 eFlags; //enumAutoTransFlags


		//the biggest difference between helpers and non-helpers is that helpers read in 
		//container args and simple args directly, and ignore other args. ATR functions need
		//to process all args, so put them in the full arg list
		ArgStruct **ppArgs;

		SimpleArgList simpleArgList;
		ContainerArgList containerArgList;
		EarrayUseList earrayUseList;
		RecursingFunctionCallList funcCallList;
		ExpectedLockList expectedLockList;

		StringTree *pCalledFunctionsNameTree;


	} AutoTransactionFunc;



private:
	AutoTransactionFunc **m_ppFuncs;

	char m_ProjectName[MAX_PATH];
	char m_AutoTransactionFileName[MAX_PATH];
	char m_AutoTransactionWrapperHeaderFileName[MAX_PATH];
	char m_AutoTransactionWrapperSourceFileName[MAX_PATH];
	char m_ShortAutoTransactionFileName[MAX_PATH];

	StringTree *m_pWhiteListTree;
	StringTree *m_pBlackListTree;
	StringTree *m_pSuperWhiteListTree;
	StringTree *m_pSafeFuncNamesTree;



private:
	static void FreeAutoTransactionFunc(AutoTransactionFunc *pFunc);	
	void AutoTransactionManager::ProcessEArrayGet(Tokenizer *pTokenizer, 
		char *pSourceFileName, SimpleArgList *pParentSimpleArgList,
		ContainerArgList *pParentContainerArgList,
		bool bUseString, enumAutoTransLockType eLockType,
		EarrayUseList *pOutEarrayUseList);
	bool FindRecurseFunctionCallContainingPoint(Tokenizer *pTokenizer, 
		int iStartingOffset, int iStartingLineNum, int iOffsetToFind, bool bOKIfArgIsDereferenced,
		SimpleArgList *pParentFuncSimpleArgList,
		char *pFuncName, int *pOutArgNum,
		RecursingFunctionCall *pOutRecursingFunctionCall);

	void ProcessArgNameInsideFunc(Tokenizer *pTokenizer, AutoTransactionFunc *pFunc, int iContainerArgIndex);

	void AddDereference(AutoTransactionFunc *pFunc, int iContainerArgIndex, char *pString, enumDerefType eType, char *pFileName, int iLineNum);


	void FuncAssert(AutoTransactionFunc *pFunc, bool bExpression, char *pErrorString);
	void FuncAssertf(AutoTransactionFunc *pFunc, bool bExpression, char *pErrorString, ...);

	void WriteTimeVerifyAutoTransValidity(AutoTransactionFunc *pFunc);

	void WriteOutAutoGenAutoTransactionPrototype(FILE *pFile, AutoTransactionFunc *pFunc, bool bAppendVersion, bool bDeferredVersion);
	void WriteOutAutoGenAutoTransactionBody(FILE *pFile, AutoTransactionFunc *pFunc, bool bAppendVersion, bool bDeferredVersion);

	void SkipSafeSimpleFunction(Tokenizer *ppTokenizer, AutoTransactionFunc *pFunc);

	bool IsFullContainerFunction(char *pFuncName, int iArgNum);
	bool IsFullContainerFunction_NoFields(char *pFuncName, int iArgNum, char *pArgTypeName);

	static int AutoTransactionComparator(const void *p1, const void *p2);

	bool FunctionNeverHasSideEffects(char *pFuncName);
	bool FunctionIsArrayOperation(char *pFuncName);
	bool FunctionIsSpecialArrayOperation(char *pFuncName);
	void DumpSimpleArgList(SimpleArgList *pSimpleArgList);

	void AddSimpleArgToSimpleArgList(Tokenizer *pTokenizer, SimpleArgList *pList, int iArgIndex, char *pArgName);

	char *GetTargetCodeArgTypeMacro(AutoTransactionFunc *pFunc, ArgStruct *pArg);
	char *GetTargetCodeArgGettingFunctionName(ArgStruct *pArg);
	int FindFuncByName(char *pString);
	enumAutoTransArgType GetArgTypeFromString(char *pArgTypeName);
	void CheckArgTypeValidity(ArgStruct *pArg, Tokenizer *pTokenizer);


	RecursingFunctionCallSimpleArg *GetNextSimpleArgForRecursingFunctionCall(Tokenizer *pTokenizer, RecursingFunctionCall *pCall);
	void AddIntArgToRecursingFunctionCall(Tokenizer *pTokenizer, RecursingFunctionCall *pCall, int iArgIndex, int iVal);
	void AddStringArgToRecursingFunctionCall(Tokenizer *pTokenizer, RecursingFunctionCall *pCall, int iArgIndex, char *pVal);
	void AddParentSimpleArgToRecursingFunctionCall(Tokenizer *pTokenizer, RecursingFunctionCall *pCall, int iArgIndex, int iParentSimpleArgIndex);
	int FindSimpleArgIndexFromList(SimpleArgList *pList, char *pArgNameToFind);
	void DumpRecursingFunctionCall(RecursingFunctionCall *pCall, SimpleArgList *pParentSimpleArgs, ContainerArgList *pParentContainerArgs);
	void DumpRecursingFunctionCallList(RecursingFunctionCallList *pList, SimpleArgList *pParentSimpleArgs, ContainerArgList *pParentContainerArgs);
	SimpleArg *FindSimpleArgFromSimpleArgListByIndex(SimpleArgList *pList, int iIndex);
	int FindContainerArgIndexFromList(ContainerArgList *pList, char *pArgNameToFind);
	void AddContainerArgToContainerArgList(Tokenizer *pTokenizer, ContainerArgList *pList, int iArgIndex, enumArgFlags eFlags, char *pArgName, char *pArgTypeName);
	void DumpEarrayUseList(EarrayUseList *pEarrayUseList, ContainerArgList *pContainerArgs, SimpleArgList *pSimpleArgs);
	ContainerArg *FindContainerArgFromContainerArgListByIndex(ContainerArgList *pList, int iIndex);

	void AddRecursingFunctionCallIfUniqueOrJustAddOneContainerArg(Tokenizer *pTokenizer, RecursingFunctionCallList *pList, RecursingFunctionCall *pCall,
		int iContainerArgIndex, int iIndexInFunctionCall, char *pDerefString);

	bool FirstDereferenceContainsSecondDereference(Dereference *pDeref1, Dereference *pDeref2);

	void GetFuncHeaderAndArgsForHelperFunc(Tokenizer *pTokenizer, AutoTransactionFunc *pFunc);
	void GetFuncHeaderAndArgsForATRFunc(Tokenizer *pTokenizer, AutoTransactionFunc *pFunc);
	void GetFuncHeaderAndArgsForSimpleHelperFunc(Tokenizer *pTokenizer, AutoTransactionFunc *pFunc);

	void DumpContainerArgList(ContainerArgList *pList);
	bool IsNeverAFunctionName(char *pString);

	void WriteSimpleArgListToFile(FILE *pOutFile, SimpleArgList *pList);
	void WriteContainerArgListToFile(FILE *pOutFile, ContainerArgList *pList);
	void WriteEarrayUseListToFile(FILE *pOutFile, EarrayUseList *pList);
	void WriteFuncCallListToFile(FILE *pOutFile, RecursingFunctionCallList *pList);
	void WriteDereferenceListToFile(FILE *pOutFile, DereferenceList *pList);
	void WriteSimpleRecursingArgListToFile(FILE *pOutFile, RecursingFunctionCallSimpleArgList *pList);
	void WriteContainerRecursingArgListToFile(FILE *pOutFile, RecursingFunctionCallContainerArgList *pList);

	void ReadSimpleArgListFromTokenizer(Tokenizer *pTokenizer, SimpleArgList *pList);
	void ReadContainerArgListFromTokenizer(Tokenizer *pTokenizer, ContainerArgList *pList);
	void ReadEarrayUseListFromTokenizer(Tokenizer *pTokenizer, EarrayUseList *pList);
	void ReadFuncCallListFromTokenizer(Tokenizer *pTokenizer, RecursingFunctionCallList *pList);
	void ReadDereferenceListFromTokenizer(Tokenizer *pTokenizer, DereferenceList *pList);
	void ReadSimpleRecursingArgListFromTokenizer(Tokenizer *pTokenizer, RecursingFunctionCallSimpleArgList *pList);
	void ReadContainerRecursingArgListFromTokenizer(Tokenizer *pTokenizer, RecursingFunctionCallContainerArgList *pList);

	bool AtLeastOneNonHelperFunc(void);
	char *GetEarrayLockTypeName(enumAutoTransLockType eLockType);
	char *GetEarrayIndexTypeName(enumRecurseArgType eArgType);
	void WriteOutAutoGenAutoTransIFDEF(FILE *pOutFile, AutoTransactionFunc *pFunc);
	void WriteOutAutoGenAutoTransENDIF(FILE *pOutFile, AutoTransactionFunc *pFunc);

	bool IsHelper(AutoTransactionFunc *pFunc) { return (pFunc->eFlags & (ATRFLAG_IS_HELPER | ATRFLAG_IS_HELPER_SIMPLE)) ? true : false; }
	bool IsSimpleDereferenceFunction(char *pFuncName);

	void AddSimpleIdentifierArgToRecursingFunctionCall(Tokenizer *pTokenizer, RecursingFunctionCall *pCall, int iArgNum, char *pString);

	void ReadExpectedLocks(Tokenizer *pTokenizer, AutoTransactionFunc *pFunc);
	ExpectedLock *FindExpectedLock(ExpectedLockList *pList, char *pName);

	void FixupExpectedLocksPostHeaderRead(Tokenizer *pTokenizer, AutoTransactionFunc *pFunc);

	void LazyInitStringTrees(void);

	void AddFunctionNameInsideTransaction(Tokenizer *pTokenizer, char *pAutoTransName, StringTree *pAutoTransFuncNameTree, char *pFuncName);

	static void GetSuspicousFunctionCallNamesCB(char *pStr, int iWordID, void *pUserData1, void *pUserData2);
	char *GetSuspicousFunctionCallNames(StringTree *pFuncNameTree);

	static void DestroyArgStruct(ArgStruct *pArg);
	static void DestroySimpleArg(SimpleArg *pArg);
	static void DestroyContainerArg(ContainerArg *pArg);
	static void DestroyEarrayUse(EarrayUse *pEarrayuse);
	static void DestroyRecursingFunctionCall(RecursingFunctionCall *pFunctionCall);
	static void DestroyExpectedLock(ExpectedLock *pLock);
	static void DestroyDereference(Dereference *pDereference);
	static void DestroyRecursingFunctionCallSimpleArg(RecursingFunctionCallSimpleArg *pArg);
	static void DestroyRecursingFunctionCallContainerArg(RecursingFunctionCallContainerArg *pArg);
	static void DestroyRecursingFunctionCallSimpleIdentifierArg(RecursingFunctionCallSimpleIdentifierArg *pArg);

	bool TokenIsReturnLoggingFuncName(char *pStr);
};



/*
AUTO_TRANSACTION
enumTransactionOutcome myFunc(ATR_ARGS, int foo, Entity *pMyEnt, float *pBar)
{
ATR_BEGIN








ATR_END
}
*/
		
#endif