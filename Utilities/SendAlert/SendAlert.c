#include "MemoryMonitor.h"
#include "FolderCache.h"
#include "sysUtil.h"
#include "UtilitiesLib.h"
#include "cmdParse.h"
#include "file.h"
#include "Estring.h"
#include "earray.h"
#include "StringCache.h"
#include "process_Util.h"
#include "net.h"
#include "../../utilities/sentryserver/sentry_comm.h"
#include "timing.h"
#include "Alerts.h"
#include "StructDefines.h"
#include "alerts_h_ast.h"
#include "CrypticPorts.h"
#include "timedCallback.h"
#include "GlobalComm.h"
#include "StructNet.h"
#include "logging.h"

char controllerTrackerName[256] = "";
AUTO_CMD_STRING(controllerTrackerName, controllerTrackerName);

char alertKey[256] = "";
AUTO_CMD_STRING(alertKey, alertKey);

char *pAlertString = NULL;
AUTO_COMMAND;
void alertString(char *pStr)
{
	estrCopy2(&pAlertString, pStr);
}

enumAlertLevel eAlertLevel = ALERTLEVEL_CRITICAL;
AUTO_COMMAND;
void level(char *pLevelName)
{
	eAlertLevel = StaticDefineIntGetIntDefault(enumAlertLevelEnum, pLevelName, ALERTLEVEL_CRITICAL);
}

enumAlertCategory eAlertCategory = ALERTCATEGORY_NETOPS;
AUTO_COMMAND;
void Category(char *pCategoryName)
{
	eAlertCategory = StaticDefineIntGetIntDefault(enumAlertCategoryEnum, pCategoryName, ALERTCATEGORY_NETOPS);
}

char criticalSystemName[256] = "";
AUTO_CMD_STRING(criticalSystemName, criticalSystemName);

//the entire alert struct... if set, overrides key/string/category/level
char *pSuperEscapedFullAlert = NULL;
AUTO_CMD_ESTRING(pSuperEscapedFullAlert, SuperEscapedFullAlert);

void CloseSoonCB(TimedCallback *callback, F32 timeSinceLastCallback, UserData userData)
{
	exit(0);
}


int main(int argc,char **argv)
{
	int i;
	bool bNeedToConfigure = false;
	CommConnectFSM *pFSM = NULL;
	int iRetryCount = 0;
	bool bSucceeded = false;
	Alert *pAlert = NULL;
	EXCEPTION_HANDLER_BEGIN
	DO_AUTO_RUNS
	setDefaultAssertMode();
	memMonitorInit();
	for(i = 0; i < argc; i++){
		printf("%s ", argv[i]);
	}
	printf("\n");

	FolderCacheChooseMode();


	preloadDLLs(0);


	utilitiesLibStartup();


	cmdParseCommandLine(argc, argv);



	srand((unsigned int)time(NULL));

	fileAllPathsAbsolute(true);


	if (!(controllerTrackerName[0] && criticalSystemName[0] && (alertKey[0] && estrLength(&pAlertString) || estrLength(&pSuperEscapedFullAlert))))
	{
		printf("Required args:\n-controllerTrackerName (Where to send the alert)\n-criticalSystemName (Name of crit system alert will pretend to be from)\n-alertKey (short KEY string for alert)\n-alertString (full string for alert)\n\n");
		printf("Optional args:\n-Level, -Category (alert level and category) (use the enum values, ie -level CRITICAL)\n");
		printf("Special arg: \n-SuperEscapedFullAlert is a stringified copy of the entire alert. This overrides key, string, and all optional args\n");
		exit(-1);
	}

	pAlert = StructCreate(parse_Alert);

	if (estrLength(&pSuperEscapedFullAlert))
	{
		char *pUnescaped = NULL;
		char *pTempAlertString = NULL;

		estrStackCreate(&pUnescaped);
		estrStackCreate(&pTempAlertString);

		estrSuperUnescapeString(&pUnescaped, pSuperEscapedFullAlert);
		ParserReadText(pUnescaped, parse_Alert, pAlert, 0);
		estrDestroy(&pUnescaped);

		estrPrintf(&pTempAlertString, "%s (generated by SendAlert.exe)", pAlert->pString);
		SAFE_FREE(pAlert->pString);
		pAlert->pString = strdup(pTempAlertString);
		estrDestroy(&pTempAlertString);


	}
	else
	{

		pAlert->eContainerTypeOfServer = GLOBALTYPE_ARBITRARYPROCESS;
		pAlert->eContainerTypeOfObject = GLOBALTYPE_ARBITRARYPROCESS;

		pAlert->iMostRecentHappenedTime = timeSecondsSince2000();
		pAlert->pKey = allocAddString(alertKey);
		pAlert->eCategory = eAlertCategory;
		pAlert->eLevel = eAlertLevel;
		estrConcatf(&pAlertString, " (generated by SendAlert.exe)");
		pAlert->pString = strdup(pAlertString);
	}


	while (!bSucceeded &&  iRetryCount < 10)
	{
		pFSM = commConnectFSM(COMMFSMTYPE_TRY_ONCE, 60, commDefault(), LINKTYPE_SHARD_NONCRITICAL_20MEG, LINK_FORCE_FLUSH, controllerTrackerName, CONTROLLERTRACKER_CRITICAL_SYSTEM_INFO_PORT, NULL, NULL, NULL, 0, NULL, NULL);
	
		while (!bSucceeded)
		{
			NetLink *pLink = NULL;
			if (pFSM)
			{
				CommConnectFSMStatus eStatus = commConnectFSMUpdate(pFSM, &pLink);

				if (eStatus == COMMFSMSTATUS_FAILED)
				{
					printf("Attempt %d: Unable to connect to controllertracker %s\n", iRetryCount, controllerTrackerName);

					if (ProcessCount("sendalert.exe", true) > 5)
					{
						printf("Too many copies of sendAlert running at once (%d), giving up to avoid flooding machine\n", 
							ProcessCount("sendalert.exe", true));
						goto Failed;
					}

					break;
				}

				if (eStatus == COMMFSMSTATUS_SUCCEEDED)
				{
					
					Packet *pPack = pktCreate(pLink, FROM_CRITICALSYSTEM_TO_CONTROLLERTRACKER_HERE_IS_ALERT);
				
					bSucceeded = true;

					pktSendString(pPack, criticalSystemName);
					ParserSendStructSafe(parse_Alert, pPack, pAlert);
					pktSend(&pPack);

					StructDestroy(parse_Alert, pAlert);

					linkFlush(pLink);

					TimedCallback_Run(CloseSoonCB, NULL, 1.0f);
					commConnectFSMDestroy(&pFSM);

					printf("Alert sent, closing soon\n");
				}
			}

	

			utilitiesLibOncePerFrame(1.0f, 1.0f);
			commMonitor(commDefault());
			Sleep(1);

		}

		if (!bSucceeded)
		{
			printf("Failed so far, will sleep 10 seconds and reattempt\n");
			iRetryCount++;
			Sleep(10000);
			commConnectFSMDestroy(&pFSM);
		}
	}


	Failed:

	if (!bSucceeded)
	{
		char *pFullString = NULL;
		ParserWriteText(&pFullString, parse_Alert, pAlert, 0, 0, 0);
		filelog_printf("SendAlert_alerts.txt", "SendAlert failed to send alert from %s to %s: %s\n",
			criticalSystemName, controllerTrackerName, pFullString);
		logFlush();
	}



	EXCEPTION_HANDLER_END

}


