// Convert CrypticLauncher-scoped translations in .translation files into CrypticLauncher message files, in XX.dat format.
// It also produced XX_nodat.txt files, for manual comparison with previous batch.
// See setMessageTable() in LauncherLocale.c for the code that reads these in.
// The .translation files are generated by POToTranslateFiles.
// This utility is a replacement for parsemessages.py.

// Syntax: CrypticLauncherImportTranslations -input <full directory path for ClientMessages.<lang code>.translation files> 
// e.g. CrypticLauncherImportTranslations -input C:\Night\data\messages

#include "cmdParse.h"
#include "file.h"
#include "FolderCache.h"
#include "Message.h"
#include "CrypticLauncherImportTranslations_c_ast.h"
#include "MemoryMonitor.h"
#include "StringUtil.h"
#include "sysUtil.h"
#include "UtilitiesLib.h"

// Input path
char g_input[MAX_PATH] = {0};
AUTO_CMD_STRING(g_input, input);

// Translated message
AUTO_STRUCT
AST_IGNORE(Description)
AST_IGNORE(Updated)
AST_IGNORE(ClientMsg)
AST_IGNORE(CoreMsg)
AST_IGNORE(Duplicate);
typedef struct TranslatedMessageWithScope
{
	// This key is used to match the translation with the primary message
	const char *pcMessageKey;	AST(KEY POOL_STRING NAME("MessageKey","MessageKeyVer3") )

	// Scope that defines where the message fits in the system.
	// Slash delimited like a file path.
	const char *pcScope;		AST(POOL_STRING SERVER_ONLY )

	// String to use if no translation is found
	char *pcDefaultString;      AST(CASE_SENSITIVE)

	// The translated string for the given locale
	char *pcTranslatedString;   AST(CASE_SENSITIVE)

	// original source filename for the text string
	char *pMsgFileName;			AST(NAME(MsgFileName)) // came from TranslatedFileMessage (POToTranslateFiles.c)
} TranslatedMessageWithScope; 

// List of TranslatedMessageWithScope
AUTO_STRUCT;
typedef struct TranslatedMessageList
{
	// All the specific translated messages
	TranslatedMessageWithScope **ppTranslatedMessages; AST(NAME("Message"))

} TranslatedMessageList;

// Localization to translate messages for
typedef struct ImportTranslation {
	const char *code;	// Language code, eg "fr"
	const char *name;	// Language name, eg "French"
	FILE *outfile;		// Output file, eg fopen("fr.dat", "wb")
	FILE *outfileNoDat;	// Output file, eg fopen("fr_nodat.txt", "wb")
} ImportTranslation;

// Generate translations for these foreign languages.
ImportTranslation translations[] = {
	{"de", "German", NULL, NULL},
	{"fr", "French", NULL, NULL},
	{"it", "Italian", NULL, NULL},
	{"ru", "Russian", NULL, NULL},
	{"pl", "Polish", NULL, NULL},
	{"zh", "ChineseSimplified", NULL, NULL},
	{"tr", "Turkish", NULL, NULL},
	{"pt", "Portuguese", NULL, NULL},
};

// English messages: MessageKey -> Defaultstring
static StashTable english_messages;

// Foreign language message translations: MessageKey","code -> Translatedstring
static StashTable translated_messages;

// Get a stash key for translated_messages.
const char *stash_key(const char *key, const char *code)
{
	char *buffer = NULL;
	estrPrintf(&buffer, "%s,%s", code, key);
	return buffer;
}

// Process a particular language.
void load_translation(ImportTranslation *translation)
{
	const char *lang = translation->name;
	const char *code = translation->code;
	char filename[MAX_PATH];
	TranslatedMessageList messages = {0};
	bool success;

	// Load translation.
	sprintf(filename, "ClientMessages.%s.translation", lang);
	success = ParserLoadFiles(g_input, filename, NULL, 0, parse_TranslatedMessageList, &messages);
	if (!success)
	{
		printf("Failed to load input file: %s", filename);
		exit(1);
	}

	// Loop over messages.
	EARRAY_CONST_FOREACH_BEGIN(messages.ppTranslatedMessages, i, n);
	{
		TranslatedMessageWithScope *message = messages.ppTranslatedMessages[i];
		if (!stricmp_safe(message->pcScope, "CrypticLauncher"))
		{
			assert(message->pcMessageKey);
			assert(message->pcDefaultString);
			stashAddPointer(english_messages, message->pcMessageKey, message->pcDefaultString, false);
			stashAddPointer(translated_messages, stash_key(message->pcMessageKey, code), message->pcTranslatedString, false);
		}
		else if (!stricmp_safe(message->pcScope, "CrypticLaunchernodat"))
		{
			char *estr = NULL;
			estrStackCreate(&estr);
			ParserWriteText(&estr, parse_TranslatedMessageWithScope, message, 0, 0, 0);
			fwrite(estr, 1, estrLength(&estr), translation->outfileNoDat);
			estrDestroy(&estr);
		}
	}
	EARRAY_FOREACH_END;
}

//
void output_language_message(FILE *outfile, const char *code, const char *key)
{
	char *message = NULL;
	BOOL found = stashFindPointer(translated_messages, stash_key(key, code), &message);
	if (found && message)
		fwrite(message, strlen(message), 1, outfile);
	fputc(0, outfile);
}

// Generate translated output files.
void generate_output()
{
	int i;
	char filename[MAX_PATH];

	// Open output files.
	FILE *english = fopen("en.dat", "wb");
	for (i = 0; i != ARRAY_SIZE(translations); ++i)
	{
		sprintf(filename, "%s.dat", translations[i].code);
		translations[i].outfile = fopen(filename, "wb");
		if (!translations[i].outfile)
		{
			printf("Failed to open output file %s", filename);
			exit(2);
		}
	}
	
	// Loop through messages and output them.
	FOR_EACH_IN_STASHTABLE2(english_messages, elem);
	{
		char *key = stashElementGetKey(elem);
		char *default_message = stashElementGetPointer(elem);

		// Write English.
		fwrite(default_message, strlen(default_message), 1, english);
		fputc(0, english);

		// Write translated messages.
		for (i = 0; i != ARRAY_SIZE(translations); ++i)
			output_language_message(translations[i].outfile, translations[i].code, key);
	}
	FOR_EACH_END;

	// Close output files.
	fclose(english);
	for (i = 0; i != ARRAY_SIZE(translations); ++i)
		fclose(translations[i].outfile);
}

// Process translation directory, full of languages.
void process()
{
	int i;

	// Initialize StashTables.
	english_messages = stashTableCreateWithStringKeys(0, StashDeepCopyKeys_NeverRelease);
	translated_messages = stashTableCreateWithStringKeys(0, StashDeepCopyKeys_NeverRelease);

	// Open nodat output files.
	for (i = 0; i != ARRAY_SIZE(translations); ++i)
	{
		char filename[MAX_PATH];
		sprintf(filename, "%s_nodat.txt", translations[i].code);
		translations[i].outfileNoDat = fopen(filename, "wb");
		if (!translations[i].outfileNoDat)
		{
			printf("Failed to open output file %s", filename);
			exit(3);
		}
	}

	// Process each language.
	for (i = 0; i != ARRAY_SIZE(translations); ++i)
		load_translation(&translations[i]);

	// Generate output files
	generate_output();

	// Close nodat output files.
	for (i = 0; i != ARRAY_SIZE(translations); ++i)
		fclose(translations[i].outfileNoDat);
}

int wmain(int argc, WCHAR** argv_wide)
{
	int i;
	char **argv;

	EXCEPTION_HANDLER_BEGIN
	ARGV_WIDE_TO_ARGV
	DO_AUTO_RUNS
	setDefaultAssertMode();
	memMonitorInit();
	for(i = 0; i < argc; i++){
		printf("%s ", argv[i]);
	}
	printf("\n");
	FolderCacheChooseMode();
	utilitiesLibStartup();
	cmdParseCommandLine(argc, argv);
	fileAllPathsAbsolute(true);

	process();

	EXCEPTION_HANDLER_END

}

#include "CrypticLauncherImportTranslations_c_ast.c"
